input {
  beats {
    port => 5044
  }
}



filter {

	if [log][file][path] == "/var/named/query.log" or  [log][file][path] == "/var/log/query.log" or [log][file][path]  == "/var/log/named/query.log" or [log][file][path] == "/var/named/log/query.log" or [log][file][path] == "/var/log/named/queries.log" {
        grok {
            match => [

                'message', '(?<timestamp>%{MONTHDAY}-%{MONTH}-%{YEAR}%{SPACE}%{TIME})%{SPACE}%{NOTSPACE}:%{SPACE}%{WORD}:%{SPACE}%{WORD}%{SPACE}%{NOTSPACE}%{SPACE}%{IPV4:sourceIP}#%{WORD}%{SPACE}%{NOTSPACE:dropdata}%{SPACE}%{WORD}:%{SPACE}%{NOTSPACE:queryDomain}%{SPACE}%{WORD}%{SPACE}%{NOTSPACE:queryType}%{SPACE}\+%{SPACE}%{NOTSPACE}'

            ]
        }
         grok { match => [ 'queryDomain', '(?<SLD>(\.[0-9A-Za-z-_]{4,62}.[0-9A-Za-z-_]{0,62}){1}$)',
                           'queryDomain', '(?<SLD>(\.[0-9A-Za-z-_]{0,62}.[0-9A-Za-z-_]{0,62}){2}$)',
                           'queryDomain', '(?<SLD>([0-9A-Za-z-_]{0,62}.[0-9A-Za-z-_]{0,62}){2}$)'
                         ]
            }

        mutate {
            remove_field => [ "host", "input", "ecs", "cloud" ]
            add_tag => "bind"
            gsub =>  [ "SLD","^.","" ]
        }
    }

    if [log][file][path] == "/var/log/rpz.log" or [log][file][path] == "/var/named/rpz.log" or [log][file][path] == "/var/named/log/rpz.log" or [log][file][path] == "/var/log/bind/rpz.log" or [log][file][path] == "/var/log/named/rpz.log" or [log][file][path] == "/var/log/named/rpz.log" {
        grok {
            match => [

                'message', '(?<timestamp>%{MONTHDAY}-%{MONTH}-%{YEAR}%{SPACE}%{TIME})%{SPACE}%{WORD}:%{SPACE}%{WORD}:%{SPACE}%{WORD}%{SPACE}%{NOTSPACE}%{SPACE}%{IPV4:sourceIP}#%{WORD}%{SPACE}%{NOTSPACE:dropdata}%{SPACE}%{WORD}%{SPACE}%{WORD}%{SPACE}%{WORD}%{SPACE}%{WORD}%{SPACE}(?<queryDomain>%{NOTSPACE})%{SPACE}%{WORD}%{SPACE}\k<queryDomain>.%{NOTSPACE:policyName}',
                'message', '(?<timestamp>%{MONTHDAY}-%{MONTH}-%{YEAR}%{SPACE}%{TIME})%{SPACE}%{WORD}:%{SPACE}%{WORD}:%{SPACE}%{WORD}%{SPACE}%{NOTSPACE}%{SPACE}%{IPV4:sourceIP}#%{WORD}%{SPACE}%{NOTSPACE:dropdata}%{SPACE}%{WORD}%{SPACE}%{WORD}%{SPACE}%{WORD}%{SPACE}%{WORD}%{SPACE}(?<queryDomain>%{NOTSPACE})%{SPACE}%{WORD}%{SPACE}(?<NOTSPACE>([0-9\.]{0,20}))rpz-ip.%{NOTSPACE:policyName}'
            ]

        }

        mutate {
            remove_field => [ "host", "input", "ecs", "cloud" ]
            add_tag => "rpz"
        }

    }

     if [log][file][path] == "/var/log/bind.log" or [log][file][path] == "/var/cache/bind/bind.log" or  [log][file][path] == "/var/named/chroot/var/log/bind.log" or [log][file][path]  == "/var/log/named/bind.log" or [log][file][path] == "/var/named/bind.log" {
        grok {
            match => [
                'message', '(?<timestamp>%{MONTHDAY}-%{MONTH}-%{YEAR}%{SPACE}%{TIME})%{SPACE}%{NOTSPACE}:%{SPACE}%{WORD}:%{SPACE}%{WORD}%{SPACE}%{NOTSPACE}%{SPACE}%{NOTSPACE}%{SPACE}\'%{HOSTNAME:zone}%{NOTSPACE}%{SPACE}from%{SPACE}%{IP:transfer_from}%{NOTSPACE}:%{SPACE}Transfer%{SPACE}status:%{SPACE}%{GREEDYDATA:status}'
            ]
        }

        mutate {
            remove_field => [ "host", "input", "ecs", "cloud" ]
            add_tag => "xfer"
            
        }
    }

    if [queryDomain] {
        mutate {
            add_field => [ "qname" , "%{queryDomain}" ]
        }
        mutate {
            split => { "qname" => "." }
        }
        mutate {
            add_field => [ "TLD" , "%{[qname][-1]}" ]
        }
        mutate {
            add_field => [ "domainIp", "%{queryDomain}" ]
        }
        
        if [domainIp] =~ /.in-addr.arpa/ {
            mutate { add_field => [ "reverseDomain" , "%{queryDomain}" ] }
            mutate { gsub => [ "reverseDomain",".in-addr.arpa","" ] }
            dns {
                nameserver => ["8.8.8.8"]
                reverse => [ "reverseDomain" ]
                #resolve => [ "reverseDomain" ]
                action => "replace"
            }
        } else {
            dns {
                nameserver => ["8.8.8.8"]
                #reverse => [ "domainIp" ]
                resolve => [ "domainIp" ]
                action => "replace"
            }
         }
        }

	if "_grokparsefailure" in [tags] {
        drop {}
    }
    
    
    geoip { source => "domainIp" }
    geoip {
          source => "domainIp"
          target => "geoip_city"
          default_database_type => "ASN"
    }
}



